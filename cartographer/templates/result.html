{% load static %}
<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <title>Térkép</title>
    <style>
    canvas {
      border: 1px solid #ccc;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
</head>
<body>
  <div class="m-2">
    <a href="{% url 'index' %}" class="btn btn-secondary">Vissza a főoldalra</a>
  </div>
  <canvas id="myCanvas" width="1000" height="650"></canvas>
  <br>
  {% for level, _ in levels %}
      <button type="button" id="level-{{ level }}" class="btn btn-sm btn-primary">{{ level }}</button>
  {% endfor %}

  <script>
    const path = {{ path_json|safe }};
    const canvas = document.getElementById('myCanvas');
    const context = canvas.getContext('2d');
    const BASEPATH = "{% static 'images/' %}";
    let currentImage = null;
    let zoom = 1.0;
    let offsetX = 0;
    let offsetY = 0;
    let isDragged = false;
    let startX, startY;
    let currentLevel = undefined;
    {% for level, _ in levels %}
        const level{{ forloop.counter0 }} = document.getElementById("level-{{ level }}")
    {% endfor %}

    canvas.addEventListener('mouseup', () => isDragged = false);
    canvas.addEventListener('mouseleave', () => isDragged = false);
    {% for level, image_name in levels %}
        level{{ forloop.counter0 }}.addEventListener('click', () => drawLevel('{{image_name}}', {{ level }}))
    {% endfor %}

    //The mouse wheel zooms the map in and out.
    canvas.addEventListener('wheel', (e) => {
     if (!currentImage) return;
     e.preventDefault();

     const rect = canvas.getBoundingClientRect();
     const mouseX = e.clientX - rect.left;
     const mouseY = e.clientY - rect.top;

     const prevZoom = zoom;
     const zoomAmount = e.deltaY * -0.001;
     zoom = Math.min(Math.max(zoom + zoomAmount, 0.5), 10.0);

     const imgAspect = currentImage.width / currentImage.height;
     const canvasAspect = canvas.width / canvas.height;
     let drawWidth, drawHeight;

     if (imgAspect > canvasAspect) {
       drawWidth = canvas.width * prevZoom;
       drawHeight = (canvas.width / imgAspect) * prevZoom;
     } else {
       drawHeight = canvas.height * prevZoom;
       drawWidth = (canvas.height * imgAspect) * prevZoom;
     }

     const prevX = (canvas.width - drawWidth) / 2 + offsetX;
     const prevY = (canvas.height - drawHeight) / 2 + offsetY;

     const mouseRelX = (mouseX - prevX) / drawWidth;
     const mouseRelY = (mouseY - prevY) / drawHeight;

     if (imgAspect > canvasAspect) {
       drawWidth = canvas.width * zoom;
       drawHeight = (canvas.width / imgAspect) * zoom;
     } else {
       drawHeight = canvas.height * zoom;
       drawWidth = (canvas.height * imgAspect) * zoom;
     }

     const newX = mouseX - mouseRelX * drawWidth;
     const newY = mouseY - mouseRelY * drawHeight;

     offsetX = newX - (canvas.width - drawWidth) / 2;
     offsetY = newY - (canvas.height - drawHeight) / 2;

     drawImage();
   });


    canvas.addEventListener('mousedown', (e) => {
      isDragged = true;
      startX = e.offsetX;
      startY = e.offsetY;
    });

    //If the left mouse button is clicked and the mouse is moved,
    //the map will be moved
    canvas.addEventListener('mousemove', (e) => {
      if (!isDragged) return;
      offsetX += e.offsetX - startX;
      offsetY += e.offsetY - startY;
      startX = e.offsetX;
      startY = e.offsetY;
      drawImage();
    });


    //Draws a new image to the canvas
    function drawLevel(imageName, level) {
      const image = new Image();
      image.src = BASEPATH + imageName;
      image.onload = function() {
        currentImage = image;
        currentLevel = level;
        zoom = 1.0;
        offsetX = 0;
        offsetY = 0;
        drawImage();
      };
    }

    //Redraws the image and the path.
    function drawImage() {
      if (!currentImage) return;
      context.clearRect(0, 0, canvas.width, canvas.height);
      const imgAspect = currentImage.width / currentImage.height;
      const canvasAspect = canvas.width / canvas.height;
      let drawWidth, drawHeight;

      if (imgAspect > canvasAspect) {
        drawWidth = canvas.width * zoom;
        drawHeight = (canvas.width / imgAspect) * zoom;
      } else {
        drawHeight = canvas.height * zoom;
        drawWidth = (canvas.height * imgAspect) * zoom;
      }

      const imageX = (canvas.width - drawWidth) / 2 + offsetX;
      const imageY = (canvas.height - drawHeight) / 2 + offsetY;
      context.drawImage(currentImage, imageX, imageY, drawWidth, drawHeight);

      if (!path || path.length === 0) return;

      const levelPoints = path.filter(nodes => nodes.level === currentLevel);

      if (levelPoints.length > 1) {
        context.beginPath();
        context.lineWidth = 2;
        context.strokeStyle = "red";

        const scaleX = drawWidth / currentImage.width;
        const scaleY = drawHeight / currentImage.height;

        for (let i = 0; i < levelPoints.length - 1; i++) {
          const sourcePoint = levelPoints[i];
          const goalPoint = levelPoints[i + 1];
          const sourceX = imageX + sourcePoint.x * scaleX;
          const sourceY = imageY + sourcePoint.y * scaleY;
          const goalX = imageX + goalPoint.x * scaleX;
          const goalY = imageY + goalPoint.y * scaleY;
          context.moveTo(sourceX, sourceY);
          context.lineTo(goalX, goalY);
        }
        context.stroke();
      }

      const scaleX = drawWidth / currentImage.width;
      const scaleY = drawHeight / currentImage.height;

      for (let i = 0; i < path.length - 1; i++) {
        const currentPoint = path[i];
        const nextPoint = path[i + 1];
        if (currentPoint.level !== nextPoint.level && currentPoint.level === currentLevel) {
          const arrowX = imageX + currentPoint.x * scaleX;
          const arrowY = imageY + currentPoint.y * scaleY;
          drawArrow(arrowX, arrowY, nextPoint.level > currentPoint.level ? "up" : "down");
        }
        else if (i === 0 && currentPoint.level === currentLevel){
            const arrowX = imageX + currentPoint.x * scaleX;
            const arrowY = imageY + currentPoint.y * scaleY;
            drawCircle(arrowX, arrowY, "black", 4)
        }
        if(i === (path.length - 2) && nextPoint.level === currentLevel){
            const arrowX = imageX + nextPoint.x * scaleX;
            const arrowY = imageY + nextPoint.y * scaleY;
            drawCircle(arrowX, arrowY, "blue", 4)
        }
      }
    }

    function drawArrow(arrowX, arrowY, direction) {
      context.fillStyle = "blue";
      context.beginPath();
      if (direction === "up") {
        context.moveTo(arrowX, arrowY - 10);
        context.lineTo(arrowX - 6, arrowY + 6);
        context.lineTo(arrowX + 6, arrowY + 6);
      } else {
        context.moveTo(arrowX, arrowY + 10);
        context.lineTo(arrowX - 6, arrowY - 6);
        context.lineTo(arrowX + 6, arrowY - 6);
      }
      context.closePath();
      context.fill();
    }

    function drawCircle(px, py, color, radius) {
      context.save();
      context.beginPath();
      context.arc(px, py, radius, 0, 2 * Math.PI);
      context.fillStyle = color;
      context.strokeStyle = "black";
      context.lineWidth = 2;
      context.fill();
      context.stroke();
      context.restore();
    }
  </script>
</body>
</html>